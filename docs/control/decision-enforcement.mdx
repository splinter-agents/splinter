---
title: Decision Enforcement
description: Lock important decisions to prevent flip-flopping
---

# Decision Enforcement

Once an agent makes an important decision, lock it so no one can change it.

## Why?

Agents can:
- Change their mind repeatedly
- Override each other's decisions
- Create inconsistent state

Decision enforcement prevents this.

## Usage

```python
from splinter.control import DecisionEnforcer, DecisionType

enforcer = DecisionEnforcer(auto_lock=True)

# Agent makes a decision - it's locked
enforcer.record_decision(
    decision_id="approach",
    agent_id="planner",
    decision_type=DecisionType.STRATEGY,
    value="parallel_processing",
    reasoning="Faster for this workload",
)

# Get decision value
approach = enforcer.get_decision("approach")  # "parallel_processing"
```

## Decision Types

| Type | Use Case |
|------|----------|
| `STRATEGY` | High-level approach |
| `CHOICE` | Selection from options |
| `COMMIT` | Commitment to action |
| `APPROVAL` | Approval/rejection |
| `DELEGATION` | Task assignment |

## Locked Decisions

```python
# Trying to change a locked decision fails
try:
    enforcer.record_decision(
        decision_id="approach",
        agent_id="researcher",  # Different agent
        decision_type=DecisionType.STRATEGY,
        value="sequential",     # Different value
    )
except DecisionLockError as e:
    print(f"Can't change: locked by {e.locked_by}")
```

## Manual Lock/Unlock

```python
# Record without auto-lock
enforcer = DecisionEnforcer(auto_lock=False)
enforcer.record_decision(decision_id="temp", ...)

# Lock later
enforcer.lock_decision("temp")

# Unlock (force required for locked decisions)
enforcer.unlock_decision("temp", force=True)
```

## Query Decisions

```python
# Get all decisions by agent
decisions = enforcer.get_decisions_by_agent("planner")

# Get all decisions by type
strategies = enforcer.get_decisions_by_type(DecisionType.STRATEGY)

# Check if locked
is_locked = enforcer.is_locked("approach")
```
