---
title: Coordination Layer
description: Multi-agent state and handoffs
---

## What is Coordination Layer?

Coordination Layer manages how agents work together:

- **Shared State**: Agents share data
- **Ownership**: Who can write what
- **Handoffs**: Validate data between agents
- **Checkpoints**: Resume failed workflows

## Shared State

All agents share a single state store.

```python
from splinter import SharedState

state = SharedState()

# Set values (supports nested paths)
state.set("research.topic", "AI")
state.set("research.findings", ["fact1", "fact2"])

# Get values
topic = state.get("research.topic")  # "AI"

# Nested access
findings = state.get("research.findings")  # ["fact1", "fact2"]
```

### Versioning

Every change increments the version.

```python
v1 = state.version  # 0
state.set("data", "value")
v2 = state.version  # 1
```

### History

```python
history = state.get_history(limit=10)
for entry in history:
    print(f"v{entry.version}: {entry.changed_fields}")
```

### Restore

```python
state.restore(version=5)  # Roll back to version 5
```

## State Ownership

Define who can write what.

```python
from splinter import StateOwnershipManager

ownership = StateOwnershipManager()

# Researcher owns research.*
ownership.register("research.*", owner="researcher")

# Summarizer owns summary.*
ownership.register("summary.*", owner="summarizer")

# Anyone can write shared.*
ownership.register("shared.*", owner="*")
```

### Enforcement

```python
ownership.check_write("researcher", "research.findings")  # OK
ownership.check_write("summarizer", "research.findings")  # Raises!
```

### In Workflow

```python
workflow.add_agent(AgentConfig(
    agent_id="researcher",
    state_ownership=["research.*"],
    ...
))
```

## Schema Handoffs

Validate data passed between agents.

```python
from splinter import HandoffManager

handoff = HandoffManager()

# Define schema for researcher â†’ summarizer
handoff.register_handoff(
    source="researcher",
    target="summarizer",
    output_schema={
        "type": "object",
        "properties": {
            "findings": {"type": "array"},
            "confidence": {"type": "number"},
        },
        "required": ["findings"],
    },
)
```

### Validation

```python
# This passes
handoff.validate_output("researcher", "summarizer", {
    "findings": ["fact1", "fact2"],
    "confidence": 0.9,
})

# This fails - missing required field
handoff.validate_output("researcher", "summarizer", {
    "confidence": 0.9,
})
# Raises SchemaValidationError
```

## Checkpointing

Save workflow state for resumption.

```python
from splinter import CheckpointManager

checkpoint_mgr = CheckpointManager()

# Create checkpoint
checkpoint_mgr.create_checkpoint(
    workflow_id="my-workflow",
    step=3,
    agent_id="researcher",
    status=AgentStatus.COMPLETED,
    state=state,
    metrics=metrics,
)
```

### Resume

```python
# Get resume point
resume = checkpoint_mgr.get_resume_point("my-workflow")
next_step, state_snapshot, metrics = resume

# Resume workflow
result = await workflow.run(resume=True)
```

### Storage Backends

```python
from splinter import InMemoryCheckpointStorage, FileCheckpointStorage

# In-memory (default)
mgr = CheckpointManager(storage=InMemoryCheckpointStorage())

# File-based
mgr = CheckpointManager(storage=FileCheckpointStorage("/path/to/checkpoints"))
```

## Protected State

Combine ownership with state access.

```python
from splinter import ProtectedState

protected = ownership.protect(state)

# Must specify agent
protected.set("research.data", value, agent_id="researcher")  # OK
protected.set("research.data", value, agent_id="summarizer")  # Raises!
```
